<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RASP入门</title>
      <link href="/2025/11/30/RASP%E5%85%A5%E9%97%A8/"/>
      <url>/2025/11/30/RASP%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考文章学习：<a href="https://www.javasec.org/java-rasp/">https://www.javasec.org/java-rasp/</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>运行时应用程序自我保护（<code>Runtime application self-protection</code>，简称<code>RASP</code>）使用Java Agent技术在应用程序运行时候动态编辑类字节码，将自身防御逻辑注入到Java底层API和Web应用程序当中，从而与应用程序融为一体，能实时分析和检测Web攻击，使应用程序具备自我保护能力。</p><p>RASP技术作为新兴的WEB防御方案，不但能够有效的防御传统WAF无法实现的攻击类型，更能够大幅提升对攻击者攻击行为的检测精准度。RASP是传统WAF的坚实后盾，能够弥补WAF无法获取Web应用<code>运行时</code>环境的缺陷，同时也是传统Web应用服务最重要的不可或缺的一道安全防线。</p><p>RASP通过注入自身到开发语言底层API中，从而完全的融入于Web服务中，拥有了得天独厚的漏洞检测和防御条件，RASP技术相较于传统的WAF拥有了更加精准、深层次的防御。RASP采用<code>基于攻击行为分析</code>的<code>主动防御</code>机制，严防<code>文件读写</code>、<code>数据访问</code>、<code>命令执行</code>等Web应用系统命脉，为Web应用安全筑建出“万丈高墙”</p><h2 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h2><p><code>JDK1.5</code>开始，<code>Java</code>新增了<code>Instrumentation（Java Agent API）</code>和<code>JVMTI（JVM Tool Interface）</code>功能，允许<code>JVM</code>在加载某个<code>class文件</code>之前对其字节码进行修改，同时也支持对已加载的<code>class（类字节码）</code>进行重新加载（<code>Retransform</code>）。</p><p>利用<code>Java Agent</code>这一特性衍生出了<code>APM（Application Performance Management，应用性能管理）</code>、<code>RASP（Runtime application self-protection，运行时应用自我保护）</code>、<code>IAST（Interactive Application Security Testing，交互式应用程序安全测试）</code>等相关产品，它们都无一例外的使用了<code>Instrumentation/JVMTI</code>的<code>API</code>来实现动态修改<code>Java类字节码</code>并插入监控或检测代码。</p><p>RASP防御的核心就是在Web应用程序执行关键的Java API之前插入防御逻辑，从而控制原类方法执行的业务逻辑。如果没有RASP的防御，攻击者可以利用Web容器/应用的漏洞攻击应用服务器</p><p><strong>示例 - Web攻击原理：</strong></p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511301451738.png" alt="img"></p><p>当Web应用接入RASP防御后，RASP会在Java语言底层重要的API（如：文件读写、命令执行等API）中设置防御点（API Hook方式），攻击者一旦发送Web攻击请求就会被RASP监控并拦截，从而有效的防御Web攻击。</p><p><strong>示例 - RASP防御原理：</strong></p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511301450951.png" alt="img"></p><p>RASP的防御能力是基于“行为实现”的，RASP会根据Hook点触发的攻击事件（如：文件读取事件、命令执行事件）调用对应的防御模块，而不需要像传统的WAF一样，一次性调用所有的防御模块。</p><h2 id="灵蜥Agent架构"><a href="#灵蜥Agent架构" class="headerlink" title="灵蜥Agent架构"></a>灵蜥Agent架构</h2><p>灵蜥Agent由两大核心机制（<code>Agent机制</code>、<code>Hook机制</code>）、三大核心模块（<code>RASP Loader</code>、<code>RASP Context</code>、<code>RASP 防御模块</code>）组成。</p><p><strong>RASP Agent架构图：</strong></p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511301450961.png" alt="image-20201121235014247"></p><p>Agent机制和Hook机制是RASP实现防御的必要条件，RASP会使用Hook机制防御容易被攻击的Java类（如：Java SE、Web应用），当被防御的类方法被调用时会自动触发RASP的防御代码</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Hook机制类似于AOP机制（<code>Aspect Oriented Programming</code>，面向切面编程），使用基于Java Agent实现的Hook技术，RASP可以实现对Java类方法执行执行前后插入自定义逻辑，从而实现控制原本的程序执行的业务逻辑</p><h2 id="ProcessBuilder-Hook"><a href="#ProcessBuilder-Hook" class="headerlink" title="ProcessBuilder Hook"></a>ProcessBuilder Hook</h2><p>未hook的原始java.lang.ProcessBuilder类代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.java_study.RASP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Hook_Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他不相关类和成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Process <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 省去其他无关代码</span></span><br><span class="line">        <span class="keyword">return</span> ProcessImpl.start(command, environment, dir, redirects, redirectErrorStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessBuilder类可以调用UNIXProcess/ProcessImpl类的native方法执行本地系统命令，默认情况下可以被任意的Java类调用，所以存在安全问题。RASP使用Agent机制动态修改了ProcessBuilder类的start方法字节码，在方法体的前后插入RASP防御代码，当start方法被调用时因为程序逻辑已被RASP更改，必须先执行RASP的防御逻辑之后才能够执行start方法的原始业务逻辑，如果RASP调用内部的检测逻辑后发现可能存在恶意攻击，RASP会终止start方法执行逻辑，从而避免了恶意攻击</p><p><strong>示例 - RASP的Hook逻辑代码片段：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.javaweb.rasp.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.agent.commons.RASPLogger;</span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.agent.hooks.advice.RASPMethodAdvice;</span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.agent.hooks.annotation.RASPClassHook;</span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.agent.hooks.annotation.RASPMethodHook;</span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.agent.utils.ClassUtils;</span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.loader.hooks.RASPHookResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hook 本地命令执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RASPClassHook</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalCommandHook</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Hook 通用的ProcessBuilder类</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@RASPMethodHook(className = &quot;java.lang.ProcessBuilder&quot;, methodName = &quot;start&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ProcessBuilderHook</span> <span class="keyword">extends</span> <span class="title class_">RASPMethodAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> RASPHookResult&lt;?&gt; onMethodEnter() &#123;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getThisObject();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取ProcessBuilder类的command变量值</span></span><br><span class="line">               List&lt;String&gt; command = ClassUtils.getFieldValue(obj, <span class="string">&quot;command&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 将执行的系统命令转换成字符串数组</span></span><br><span class="line">               String[] commands = command.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[command.size()]);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 调用processCommand方法，检测执行的本地命令合法性</span></span><br><span class="line">               <span class="keyword">return</span> LocalCommandHookHandler.processCommand(commands, obj, <span class="built_in">this</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   RASPLogger.log(AGENT_NAME + <span class="string">&quot;获取ProcessBuilder类command变量异常:&quot;</span> + e, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RASPHookResult</span>(RETURN);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 省略其他本地命令执行Hook点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 - 经过RASP修改后的java.lang.ProcessBuilder类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.loader.hooks.RASPHookHandlerType;</span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.loader.hooks.RASPHookProxy;</span><br><span class="line"><span class="keyword">import</span> org.javaweb.rasp.loader.hooks.RASPHookResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProcessBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Process <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">// 生成Object数组对象，存储方法参数值</span></span><br><span class="line">      Object[] parameters = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 生成try/catch</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用RASP方法方法进入时检测逻辑</span></span><br><span class="line">          RASPHookResult&lt;?&gt; enterResult = RASPHookProxy.onMethodEnter(parameters, ...);</span><br><span class="line">          <span class="type">String</span> <span class="variable">HandlerType</span> <span class="operator">=</span> enterResult.getRaspHookHandlerType().toString();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (RASPHookHandlerType.REPLACE_OR_BLOCK.toString().equals(HandlerType)) &#123;</span><br><span class="line">              <span class="comment">// 如果RASP检测结果需要阻断或替换程序执行逻辑，return RASP返回结果中设置的返回值</span></span><br><span class="line">              <span class="keyword">return</span> (Process) enterResult.getReturnValue();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (RASPHookHandlerType.THROW.toString().equals(HandlerType)) &#123;</span><br><span class="line">              <span class="comment">// 如果RASP检测结果需要往外抛出异常，throw RASP返回结果中设置的异常对象</span></span><br><span class="line">              <span class="keyword">throw</span> (Throwable) enterResult.getException();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行程序原逻辑，执行本地系统命令并返回Process对象</span></span><br><span class="line">          <span class="type">Process</span> <span class="variable">methodReturn</span> <span class="operator">=</span> ProcessImpl.start(command, environment, dir, redirects, redirectErrorStream);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 调用RASP方法方法退出时检测逻辑，同onMethodEnter，此处省略对应代码</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> methodReturn;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 调用RASP方法方法异常退出时检测逻辑，同onMethodEnter，此处省略对应代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RASP-Hook与Java-Web攻击"><a href="#RASP-Hook与Java-Web攻击" class="headerlink" title="RASP Hook与Java Web攻击"></a>RASP Hook与Java Web攻击</h2><p>常见的Java Web攻击方式最终几乎都会调用对应的Java类方法执行，而RASP恰好可以使用Hook机制控制任意的Java类方法执行逻辑，因此RASP可以使用Hook机制将易受攻击的Java类进行监控，从而实现防止恶意的Java Web攻击</p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511301450679.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> RASP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>污点分析</title>
      <link href="/2025/11/26/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/"/>
      <url>/2025/11/26/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习该知识点的网址：<a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.5_taint_analysis.html">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.5_taint_analysis.html</a></p><p>文章掺杂了一些个人的学习思考（不是绝对正确）</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>污点分析是一种跟踪并分析污点信息在程序中流动的技术。在漏洞分析中，使用污点分析技术将所感兴趣的数据（通常来自程序的外部输入）标记为污点数据，然后通过跟踪和污点数据相关的信息的流向，可以知道它们是否会影响某些关键的程序操作，进而挖掘程序漏洞。即将程序是否存在某种漏洞的问题转化为污点信息是否会被 Sink 点上的操作所使用的问题</p><p>Eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);    <span class="comment">// Source 点，输入数据被标记为污点信息，并且认为变量 x 是污染的</span></span><br><span class="line">[...]</span><br><span class="line">y = x + k;          <span class="comment">// 如果二元操作的操作数是污染的，那么操作结果也是污染的，所以变量 y 也是污染的</span></span><br><span class="line">[...]</span><br><span class="line">x = <span class="number">0</span>;              <span class="comment">// 如果一个被污染的变量被赋值为一个常数，那么认为它是未污染的，所以 x 转变成未污染的</span></span><br><span class="line">[...]</span><br><span class="line"><span class="keyword">while</span> (i &lt; y)       <span class="comment">// Sink 点，如果规定循环的次数不能受程序输入的影响，那么需要检查 y 是否被污染</span></span><br></pre></td></tr></table></figure><p>污点信息不仅可以通过数据依赖传播，还可以通过控制依赖传播。我们将通过数据依赖传播的信息流称为显式信息流，将通过控制依赖传播的信息流称为隐式信息流</p><p>Eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>变量 y 的取值依赖于变量 x 的取值，如果变量 x 是污染的，那么变量 y 也应该是污染的</p><p>对于漏洞的污点分析逻辑其实也是基于上述逻辑：</p><p>Eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> getUser();</span><br><span class="line"><span class="type">String</span> <span class="variable">pass</span> <span class="operator">=</span> getPass();</span><br><span class="line"><span class="type">String</span> <span class="variable">sqlQuery</span> <span class="operator">=</span> <span class="string">&quot;select * from login where user=&#x27;&quot;</span> + user + <span class="string">&quot;&#x27; and pass=&#x27;&quot;</span> + pass + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stam</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">ResultSetrs = stam.executeQuery(sqlQuery);</span><br><span class="line"><span class="keyword">if</span> (rs.next())</span><br><span class="line">    success = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>污点分析中，user和pass是会被标记为污点信息，污点信息进入到sql语句中，那么就会被污点分析判定为sql注入漏洞</p><p>流程大致为：</p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511261023574.png" alt="img"></p><p>在分析过程中：</p><ul><li>基于数据流的污点分析。在不考虑隐式信息流的情况下，可以将污点分析看做针对污点数据的数据流分析。根据污点传播规则跟踪污点信息或者标记路径上的变量污染情况，进而检查污点信息是否影响敏感操作</li><li>基于依赖关系的污点分析。考虑隐式信息流，在分析过程中，根据程序中的语句或者指令之间的依赖关系，检查 Sink 点处敏感操作是否依赖于 Source 点处接收污点信息的操作</li></ul><h2 id="污点分析的实现"><a href="#污点分析的实现" class="headerlink" title="污点分析的实现"></a>污点分析的实现</h2><h3 id="基于数据流的污点分析实现"><a href="#基于数据流的污点分析实现" class="headerlink" title="基于数据流的污点分析实现"></a>基于数据流的污点分析实现</h3><p>在基于数据流的污点分析中，常常需要一些辅助分析技术，例如别名分析、取值分析等，来提高分析精度。辅助分析和污点分析交替进行，通常沿着程序路径的方向分析污点信息的流向，检查 Source 点处程序接收的污点信息是否会影响到 Sink 点处的敏感操作</p><p><strong>过程内的分析</strong>中，会按照一定的顺序分析过程内的每一条语句或者指令，进而分析污点信息的流向，顺序如下：</p><ol><li><p>记录污点信息</p><p>在静态分析层面，程序变量的污染情况为主要关注对象。为记录污染信息，通常为变量添加一个污染标签。最简单的就是一个布尔型变量，表示变量是否被污染。更复杂的标签还可以记录变量的污染信息来自哪些 Source 点，甚至精确到 Source 点接收数据的哪一部分。当然也可以不使用污染标签，这时我们通过对变量进行跟踪的方式达到分析污点信息流向的目的。例如使用栈或者队列来记录被污染的变量</p></li><li><p>程序语句的分析</p><p>确定好污点信息，需要对程序语句进行静态分析</p><ul><li><p>赋值语句</p><p>对于简单的<code>b=a</code>，直接对两侧进行到相同状态的标记，而对于常量<code>a=&#39;n11&#39;</code>，在不考虑隐式信息流的情况下，都看作不被污染</p><p>对于<code>a= b+c</code>，右侧有1个被污染，则视作左侧被污染</p><p>对于数组类型，本因通过数组下标进行污染标记，更准确，但是通常静态分析不能确定一个变量是被污染的，而是默认为整个数组被污染–&gt;也可以看到其可能会存在误报</p><p>对于包含指针或者指针赋值的场景，则需要用到指针分析技术</p></li></ul><ul><li><p>控制转移语句</p><p>对于循环语句，通常规定循环变量的取值范围不能受到输入的影响。例如在语句 <code>for (i = 1; i &lt; k; i++)&#123;&#125;</code> 中，可以规定循环的上界 k 不能是污染的</p><p>对于条件控制语句，如果说对于污染变量的限制足够完整，那么该污染变量不应该被视作被污染，eg:sql语句中的参数id，本应该被识别为污染变量，如果加了一个白名单只能使用数字，那么可以说这个变量id不是污染变量</p></li></ul><ul><li><p>过程调用语句</p><p>可以使用过程间的分析或者直接应用过程摘要进行分析。污点分析所使用的过程摘要主要描述怎样改变与该过程相关的变量的污染状态，以及对哪些变量的污染状态进行检测。这些变量可以是过程使用的参数、参数的字段或者过程的返回值等。例如在语句 <code>flag = obj.method(str);</code> 中，str 是污染的，那么通过过程间的分析，将变量 obj 的字段 str 标记为污染的，而记录方法的返回值的变量 flag 需要根据返回值与污染变量的相关性来判断是否被污染</p><p>上述过程间分析结果不管是返回的值赋予flag是污染还是被污染，都会对其进行构建过程摘要，然后对于下次需要过程间分析时，直接分析摘要，好处是提高效率，例如一个方法会被调用上千上万次，每次都进行过程间分析，会很浪费资源，直接分析摘要，输入污染输出污染或者输入污染，返回无污染等</p></li></ul><p>3.代码的遍历</p><ul><li><p>流敏感</p><p>流敏感分析会按顺序追踪代码，并且在遇到赋值语句时更新变量的状态。它关心的是<strong>在代码的某一特定行上，某个变量的状态是什么</strong></p><table><thead><tr><th><strong>代码行</strong></th><th><strong>代码</strong></th><th><strong>流不敏感分析 (保守)</strong></th><th><strong>流敏感分析 (精确)</strong></th></tr></thead><tbody><tr><td><strong>L1</strong></td><td><code>a = 5;</code></td><td><code>a</code> 是一个常量</td><td><code>a</code> 是 5</td></tr><tr><td><strong>L2</strong></td><td><code>b = a;</code></td><td><code>b</code> 是一个常量</td><td><code>b</code> 是 5</td></tr><tr><td><strong>L3</strong></td><td><code>a = userInput();</code></td><td><code>a</code> 是<strong>常量</strong>或<strong>污点</strong> (取决于起点)</td><td><code>a</code> 现在是<strong>污点</strong></td></tr><tr><td><strong>L4</strong></td><td><code>print(b);</code></td><td>无法确定 <code>b</code> 的确切值</td><td><code>b</code> 仍然是 5 (在 L3 赋值之前确定)</td></tr></tbody></table></li><li><p>路径敏感</p><p>路径敏感分析比流敏感更进一步。它不仅仅按顺序执行语句，还会<strong>跟踪并分离所有可能的执行路径</strong>，并为每条路径维护不同的变量状态</p><table><thead><tr><th><strong>代码行</strong></th><th><strong>代码</strong></th><th><strong>流敏感分析 (保守)</strong></th><th><strong>路径敏感分析 (精确)</strong></th></tr></thead><tbody><tr><td><strong>L1</strong></td><td><code>input = getUserInput();</code></td><td><code>input</code> 是<strong>污点</strong></td><td><code>input</code> 是<strong>污点</strong></td></tr><tr><td><strong>L2</strong></td><td><code>if (input.isNumeric()) &#123;</code></td><td>无法确定 <code>input</code> 的精确类型</td><td>开始分离路径</td></tr><tr><td><strong>L3</strong></td><td><code>// 路径 A (数字)</code></td><td></td><td>路径 A：<code>input</code> 是<strong>已净化</strong> (只包含数字)</td></tr><tr><td><strong>L4</strong></td><td><code>db.query(input);</code></td><td><strong>可能报告漏洞</strong> (因为 <code>input</code> 是泛指的污点)</td><td><strong>不会报告漏洞</strong> (因为 <code>input</code> 在此路径是数字)</td></tr><tr><td><strong>L5</strong></td><td><code>&#125; else &#123; // 路径 B (非数字)</code></td><td></td><td>路径 B：<code>input</code> 是<strong>污点</strong> (包含非数字字符)</td></tr><tr><td><strong>L6</strong></td><td><code>log.error(input);</code></td><td>报告信息泄露 (如果 <code>log.error</code> 是 Sink)</td><td><strong>报告信息泄露</strong></td></tr></tbody></table><p>路径敏感的分析步骤中可以看到是减少一定的误报量的</p><p>一般情况下，常常使用流敏感的方式或者路径敏感的方式进行遍历，并分析过程中的代码。如果使用流敏感的方式，可以通过对不同路径上的分析结果进行汇集，以发现程序中的数据净化规则。如果使用路径敏感的分析方式，则需要关注路径条件，如果路径条件中涉及对污染变量取值的限制，可认为路径条件对污染数据进行了净化，还可以将分析路径条件对污染数据的限制进行记录，如果在一条程序路径上，这些限制足够保证数据不会被攻击者利用，就可以将相应的变量标记为未污染的</p></li></ul><p><strong>过程间的分析</strong>与数据流过程间分析类似，使用自底向上的分析方法，分析调用图中的每一个过程，进而对程序进行整体的分析</p></li></ol><h3 id="基于依赖的污点分析实现"><a href="#基于依赖的污点分析实现" class="headerlink" title="基于依赖的污点分析实现"></a>基于依赖的污点分析实现</h3><p>在基于依赖关系的污点分析中，首先利用程序的中间表示（IR）、控制流图(CFG)和过程调用图构造程序完整的或者局部的程序的依赖关系。在分析程序依赖关系后，根据污点分析规则，检测 Sink 点处敏感操作是否依赖于 Source 点</p><p>分析程序依赖关系的过程可以看做是构建程序依赖图的过程。程序依赖图是一个有向图。它的节点是程序语句，它的有向边表示程序语句之间的依赖关系。程序依赖图的有向边常常包括数据依赖边和控制依赖边。在构建有一定规模的程序的依赖图时，需要按需地构建程序依赖关系，并且优先考虑和污点信息相关的程序代码。</p><p>Eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>); <span class="comment">// Source (污点源)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// L2</span></span><br><span class="line">String filteredName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// L3</span></span><br><span class="line"><span class="keyword">if</span> (username.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// L4</span></span><br><span class="line">    filteredName = sanitize(username);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// L5</span></span><br><span class="line">    filteredName = <span class="string">&quot;Guest&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// L6</span></span><br><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name) VALUES (&#x27;&quot;</span> + filteredName + <span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// L7</span></span><br><span class="line">db.execute(query); <span class="comment">// Sink (敏感操作)</span></span><br></pre></td></tr></table></figure><p>其程序依赖图（抽象图示）：</p><table><thead><tr><th><strong>语句</strong></th><th><strong>数据依赖于…</strong></th><th><strong>控制依赖于…</strong></th></tr></thead><tbody><tr><td><strong>L1:</strong> <code>username = ...</code></td><td>无</td><td>无 (入口节点)</td></tr><tr><td><strong>L2:</strong> <code>filteredName;</code></td><td>无</td><td>无</td></tr><tr><td><strong>L3:</strong> <code>if (...)</code></td><td>L1</td><td>无</td></tr><tr><td><strong>L4:</strong> <code>filteredName = sanitize(...);</code></td><td>L3 (条件)、L1 (数据)</td><td>L3 (if 条件为真)</td></tr><tr><td><strong>L5:</strong> <code>filteredName = &quot;Guest&quot;;</code></td><td>L3 (条件)</td><td>L3 (if 条件为假)</td></tr><tr><td><strong>L6:</strong> <code>query = ... + filteredName</code></td><td>L4 或 L5</td><td>无 (在 if 之外)</td></tr><tr><td><strong>L7:</strong> <code>db.execute(query);</code></td><td>L6</td><td>无</td></tr></tbody></table><p><strong>目标：</strong> 检测 Sink (L7) 是否依赖于 Source (L1)。</p><p>PDG 分析的强大之处在于它的<strong>反向分析（切片）和按需构建</strong>：</p><p>PDG 允许分析器从 <strong>Sink 点（L7）</strong>开始，逆着依赖边往回追踪：</p><ol><li><strong>从 Sink L7 开始：</strong> <code>db.execute(query)</code> 依赖于 <code>query</code> (L6)。</li><li><strong>追踪 L6：</strong> <code>query</code> (L6) 依赖于 <code>filteredName</code> (L4 和 L5)。</li><li><strong>追踪 L4 和 L5 (数据依赖)：</strong><ul><li><strong>L5 路径：</strong> <code>filteredName = &quot;Guest&quot;</code>。这是一个<strong>安全常量</strong>。此路径终止。</li><li><strong>L4 路径：</strong> <code>filteredName = sanitize(username)</code>。</li></ul></li><li><strong>追踪 L4 (数据和控制依赖)：</strong> L4 依赖于 <code>username</code> (L1) 和 L3 (控制条件)。</li><li><strong>追踪 L1：</strong> L1 是 <code>Source</code></li></ol><p> 如果程序有 1000 个函数，但 L7 只使用了 3 个函数中的变量，PDG 分析器会<strong>只构建</strong>这 3 个函数所涉及的依赖图，忽略其他 997 个不相关的函数，从而极大地提高分析效率。</p><h2 id="动态污点分析"><a href="#动态污点分析" class="headerlink" title="动态污点分析"></a>动态污点分析</h2><h3 id="动态污点标记"><a href="#动态污点标记" class="headerlink" title="动态污点标记"></a>动态污点标记</h3><p>污点数据通常主要是指软件系统所接受的外部输入数据，在计算机中，这些数据可能以内存临时数据的形式存储，也可能以文件的形式存储。当程序需要使用这些数据时，一般通过函数或系统调用来进行数据访问和处理，因此只需要对这些关键函数进行监控，即可得到程序读取或输出了什么污点信息。另外对于网络输入，也需要对网络操作函数进行监控。</p><p>识别出污点数据后，需要对污点进行标记。污点生命周期是指在该生命周期的时间范围内，污点被定义为有效。污点生命周期开始于污点创建时刻，生成污点标记，结束于污点删除时刻，清除污点标记。</p><ul><li>污点创建<ul><li>将来自于非可靠来源的数据分配给某寄存器或内存操作数时</li><li>将已经标记为污点的数据通过运算分配给某寄存器或内存操作数时</li></ul></li><li>污点删除<ul><li>将非污点数据指派给存放污点的寄存器或内存操作数时</li><li>将污点数据指派给存放污点的寄存器或内存地址时，此时会删除原污点，并创建新污点</li><li>一些会清除污点痕迹的算数运算或逻辑运算操作时</li></ul></li></ul><h3 id="污点动态跟踪"><a href="#污点动态跟踪" class="headerlink" title="污点动态跟踪"></a>污点动态跟踪</h3><p>当污点数据从一个位置传递到另一个位置时，则认为产生了污点传播。污点传播规则：</p><table><thead><tr><th>指令类型</th><th>传播规则</th><th>举例说明</th></tr></thead><tbody><tr><td>拷贝或移动指令</td><td>T(a)&lt;-T(b)</td><td>mov a, b</td></tr><tr><td>算数运算指令</td><td>T(a)&lt;-T(b)</td><td>add a, b</td></tr><tr><td>堆栈操作指令</td><td>T(esp)&lt;-T(a)</td><td>push a</td></tr><tr><td>拷贝或移动类函数调用指令</td><td>T(dst)&lt;-T(src)</td><td>call memcpy</td></tr><tr><td>清零指令</td><td>T(a)&lt;-false</td><td>xor a, a</td></tr></tbody></table><p>注：T(x) 的取值分为 true 和 false 两种，取值为 true 时表示 x 为污点，否则 x 不是污点。</p><p>对于污点信息流，通过污点跟踪和函数监控，已经能够进行污点信息流流动方向的分析。但由于缺少对象级的信息，仅靠指令级的信息流动并不能完全给出要分析的软件的确切行为</p><p>Eg：</p><table><thead><tr><th><strong>语句 ID</strong></th><th><strong>代码/指令</strong></th><th><strong>污点追踪结果</strong></th></tr></thead><tbody><tr><td><strong>L1</strong></td><td><code>handle = open(path, mode)</code></td><td><code>path</code> 是用户输入（污点）</td></tr><tr><td><strong>L2</strong></td><td><code>data = read(handle)</code></td><td><code>data</code> 的污点状态从 <code>handle</code> 继承</td></tr><tr><td><strong>L3</strong></td><td><code>socket.send(data)</code></td><td><code>data</code> 是污点，流入网络 Sink</td></tr></tbody></table><p><strong>仅靠指令级流动分析，会得出结论：</strong> 用户控制的 <code>path</code> 最终影响了网络传输的 <code>data</code>，存在<strong>路径穿越漏洞</strong>或<strong>信息泄露</strong></p><p>但这个结论可能是不准确的，因为我们缺少关于 <code>handle</code>（文件对象）和 <code>socket</code>（套接字对象）的<strong>完整状态</strong></p><ul><li><strong>对于 <code>handle</code> (文件对象)：</strong><ul><li><strong>指令级只知道：</strong> 它是一个文件句柄。</li><li><strong>对象级信息缺失：</strong> 我们不知道这个文件句柄是<strong>什么文件</strong>。<ul><li>如果是 <code>handle = open(&quot;/etc/passwd&quot;, &quot;r&quot;)</code>，那么 L3 的行为是<strong>巨大的信息泄露</strong>。</li><li>如果是 <code>handle = open(&quot;/tmp/log.txt&quot;, &quot;w&quot;)</code>，而日志文件内容是程序内部生成的，那么 L3 的行为可能只是<strong>正常日志发送</strong>。</li></ul></li><li><strong>结论：</strong> 缺少<strong>文件路径和权限</strong>这个“对象级信息”，我们无法准确评估风险。</li></ul></li><li><strong>对于 <code>socket</code> (套接字对象)：</strong><ul><li><strong>指令级只知道：</strong> 数据被发送到网络。</li><li><strong>对象级信息缺失：</strong> 我们不知道这个套接字连接到<strong>哪里</strong>。<ul><li>如果是连接到外部攻击者的 IP/端口，那么 L3 的行为是<strong>命令执行结果回传</strong>（严重的 RCE）。</li><li>如果是连接到 <code>127.0.0.1:8080</code>（即本地内部服务），那么 L3 的行为可能只是<strong>正常的内部服务间通信</strong>。</li></ul></li><li><strong>结论：</strong> 缺少<strong>远程 IP 地址和端口</strong>这个“套接字对象的详细信息”，我们无法判断是否存在 SSRF 或 RCE 风险。</li></ul></li></ul><h4 id="根据漏洞分析的实际需求，污点分析应包括两方面的信息："><a href="#根据漏洞分析的实际需求，污点分析应包括两方面的信息：" class="headerlink" title="根据漏洞分析的实际需求，污点分析应包括两方面的信息："></a>根据漏洞分析的实际需求，污点分析应包括两方面的信息：</h4><ul><li>污点的传播关系，对于任一污点能够获知其传播情况</li><li>对污点数据进行处理的所有指令信息，包括指令地址、操作码、操作数以及在污点处理过程中这些指令执行的先后顺序等</li></ul><h4 id="根据动态跟踪的实现通常使用："><a href="#根据动态跟踪的实现通常使用：" class="headerlink" title="根据动态跟踪的实现通常使用："></a>根据动态跟踪的实现通常使用：</h4><p>Eg:监控以下C/C++伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L1: 用户输入，被标记为污点源</span></span><br><span class="line"><span class="type">char</span>* input = GetUserInput(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// L2: 字符串拷贝到缓冲区</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buffer, input); </span><br><span class="line"></span><br><span class="line"><span class="comment">// L3: 字符串连接，污点传递</span></span><br><span class="line"><span class="type">char</span> query[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(query, <span class="string">&quot;SELECT * FROM users WHERE name = &#x27;%s&#x27;&quot;</span>, buffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// L4: 敏感操作，Sink点</span></span><br><span class="line">ExecuteSQL(query);</span><br></pre></td></tr></table></figure><ol><li>影子内存：真实内存中污点数据的镜像，用于存放程序执行的当前时刻所有的有效污点</li></ol><table><thead><tr><th><strong>真实内存地址 (假设)</strong></th><th><strong>真实内存内容</strong></th><th><strong>影子内存地址</strong></th><th><strong>影子内存内容 (污点标签)</strong></th></tr></thead><tbody><tr><td><code>0x1000</code></td><td><code>&#39;A&#39;</code></td><td><code>0x2000</code></td><td><strong>Taint ID (如 #1)</strong></td></tr><tr><td><code>0x1001</code></td><td><code>&#39;B&#39;</code></td><td><code>0x2001</code></td><td><strong>Taint ID (如 #1)</strong></td></tr><tr><td><code>0x1002</code></td><td><code>&#39;\0&#39;</code></td><td><code>0x2002</code></td><td><strong>Clean (干净)</strong></td></tr><tr><td><code>0x1003</code></td><td><code>...</code></td><td><code>0x2003</code></td><td><strong>Clean (干净)</strong></td></tr></tbody></table><p>对应示例：</p><ul><li><strong>L1 (<code>input = GetUserInput();</code>)**：当用户输入的数据（假设存放在 <code>0x1000</code> 开始的内存）进入程序时，DTA 系统会立即在对应的</strong>影子内存<strong>区域（假设 <code>0x2000</code> 开始）标记上一个唯一的</strong>污点 ID (#1)**。</li><li><strong>L2 (<code>strcpy(buffer, input);</code>)**：当数据从 <code>input</code> 拷贝到 <code>buffer</code> 时，DTA 系统会检查 <code>input</code> 的影子内存，发现其有污点 ID #1。于是，它将这个污点 ID 复制到 <code>buffer</code> 对应内存的</strong>影子内存**中。</li></ul><p><strong>作用：</strong> 影子内存提供了一个<strong>即时、高效</strong>的查询机制，用于判断任何内存位置的数据在<strong>当前时刻</strong>是否被污染。</p><ol start="2"><li>污点传播树：一种树形结构，记录污点数据<strong>从 Source 到 Sink 的整个衍变和传播路径</strong>。它记录了污点的<strong>来源</strong>和<strong>传递关系</strong>。</li></ol><p>对应示例：</p><p>当污点从一个变量传递到另一个变量时，传播树的节点就会增加，记录这个“谁来自谁”的关系。</p><ol><li><p><strong>根节点：</strong> Taint ID #1 (来自 <code>GetUserInput()</code>)</p></li><li><p><strong>第一次传播 (L2):</strong> 节点 #2 (变量 <code>buffer</code>) 的污点来自 Taint ID #1。</p></li></ol><ul><li><strong>树结构：</strong> <code>Taint #1</code> $\rightarrow$ <code>Buffer</code></li></ul><ol start="3"><li><strong>第二次传播 (L3):</strong> 节点 #3 (变量 <code>query</code>) 的污点来自 <code>buffer</code>。</li></ol><ul><li><strong>树结构：</strong> <code>Taint #1</code> $\rightarrow$ <code>Buffer</code> $\rightarrow$ <code>Query</code></li></ul><p><strong>作用：</strong>如果在 Sink 点（L4）发现 <code>query</code> 是污点，可以通过<strong>回溯</strong>传播树，立即确定原始污点源是哪个 <code>GetUserInput()</code> 调用，以及中间经过了哪些变量。这对于<strong>生成漏洞报告</strong>至关重要</p><ol start="3"><li>污点处理指令链：按时间顺序，记录所有<strong>涉及污点数据操作的指令</strong>序列。它记录了污点在传播过程中被<strong>处理</strong>的<strong>操作历史</strong></li></ol><p>对应示例:</p><table><thead><tr><th><strong>顺序</strong></th><th><strong>指令地址 (或 L 编号)</strong></th><th><strong>操作类型</strong></th><th><strong>污点数据</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td>L1</td><td><strong>Source</strong></td><td><code>input</code></td><td>污点源，ID #1</td></tr><tr><td>2</td><td>L2</td><td><strong>Copy</strong></td><td><code>strcpy</code></td><td>污点从 <code>input</code> $\rightarrow$ <code>buffer</code></td></tr><tr><td>3</td><td>L3</td><td><strong>Combine</strong></td><td><code>sprintf</code></td><td>污点与干净数据合并 $\rightarrow$ <code>query</code></td></tr><tr><td>4</td><td>L4</td><td><strong>Sink</strong></td><td><code>ExecuteSQL</code></td><td>污点流入敏感函数</td></tr></tbody></table><p><strong>作用：</strong></p><ul><li><strong>检测净化函数：</strong> 如果在指令链中发现 <code>sanitize(buffer)</code> 这样的指令，分析器可以判断这是一个<strong>净化操作</strong>。它会检查该操作是否足以清除污点。</li><li><strong>漏洞证据：</strong> 指令链提供了漏洞利用的<strong>确切执行路径</strong>和<strong>操作序列</strong>。例如，如果 <code>ExecuteSQL</code> 依赖于 <code>query</code>，指令链清晰地展示了 <code>query</code> 是如何一步步被用户输入构建起来的</li></ul><p>以上三种机制是一个<strong>完整的 DTA（Dynamic Taint Analysis） 追踪系统</strong></p><p>当遇到会引起污点传播的指令时，首先对指令中的每个操作数都通过污点快速映射查找影子内存中是否存在与之对应的影子污点从而确定其是否为污点数据，然后根据污点传播规则得到该指令引起的污点传播结果，并将传播产生的新污点添加到影子内存和污点传播树中，同时将失效污点对应的影子污点删除。同时由于一条指令是否涉及污点数据的处理，需要在污点分析过程中动态确定，因此需要在污点处理指令链中记录污点数据的指令信息</p><h3 id="动态污点实例分析"><a href="#动态污点实例分析" class="headerlink" title="动态污点实例分析"></a>动态污点实例分析</h3><p>Eg：检测缓冲区溢出漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">15</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in strncpy, source: %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">strncpy</span>(temp, str, <span class="built_in">strlen</span>(str));        <span class="comment">// Sink 点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> source[<span class="number">30</span>];</span><br><span class="line">    gets(source);                           <span class="comment">// Source 点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(source) &lt; <span class="number">30</span>)</span><br><span class="line">        fun(source);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;too long string, %s\n&quot;</span>, source);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序接受外部输入字符串的二进制代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x08048609 &lt;+51&gt;:    lea    eax,[ebp-0x2a]</span><br><span class="line">0x0804860c &lt;+54&gt;:    push   eax</span><br><span class="line">0x0804860d &lt;+55&gt;:    call   0x8048400 &lt;gets@plt&gt;</span><br><span class="line">...</span><br><span class="line">0x0804862c &lt;+86&gt;:    lea    eax,[ebp-0x2a]</span><br><span class="line">0x0804862f &lt;+89&gt;:    push   eax</span><br><span class="line">0x08048630 &lt;+90&gt;:    call   0x8048566 &lt;fun&gt;</span><br></pre></td></tr></table></figure><p>程序调用 strncpy 函数的二进制代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x080485a1 &lt;+59&gt;:    push   DWORD PTR [ebp-0x2c]</span><br><span class="line">0x080485a4 &lt;+62&gt;:    call   0x8048420 &lt;strlen@plt&gt;</span><br><span class="line">0x080485a9 &lt;+67&gt;:    add    esp,0x10</span><br><span class="line">0x080485ac &lt;+70&gt;:    sub    esp,0x4</span><br><span class="line">0x080485af &lt;+73&gt;:    push   eax</span><br><span class="line">0x080485b0 &lt;+74&gt;:    push   DWORD PTR [ebp-0x2c]</span><br><span class="line">0x080485b3 &lt;+77&gt;:    lea    eax,[ebp-0x1b]</span><br><span class="line">0x080485b6 &lt;+80&gt;:    push   eax</span><br><span class="line">0x080485b7 &lt;+81&gt;:    call   0x8048440 &lt;strncpy@plt&gt;</span><br></pre></td></tr></table></figure><p>首先，在扫描该程序的二进制代码时，能够扫描到 <code>call &lt;gets@plt&gt;</code>，该函数会读入外部输入，即程序的攻击面。确定了攻击面后，我们将分析污染源数据并进行标记，即将 <code>[ebp-0x2a]</code> 数组（即源程序中的source）标记为污点数据。程序继续执行，该污染标记会随着该值的传播而一直传递。在进入 <code>fun()</code> 函数时，该污染标记通过形参实参的映射传递到参数 <code>str</code> 上。然后运行到 Sink 点函数 <code>strncpy()</code>。该函数的第二个参数即 <code>str</code> 和 第三个参数 <code>strlen(str)</code> 都是污点数据。最后在执行 <code>strncpy()</code> 函数时，若设定了相应的漏洞规则（目标数组小于源数组），则漏洞规则将被触发，检测出缓冲区溢出漏洞</p>]]></content>
      
      
      <categories>
          
          <category> SDL </category>
          
          <category> SAST </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SAST入门</title>
      <link href="/2025/11/25/SAST%E5%85%A5%E9%97%A8/"/>
      <url>/2025/11/25/SAST%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="SAST"><a href="#SAST" class="headerlink" title="SAST"></a>SAST</h2><p>SAST所涉及到的内容：</p><p><strong>SAST (Static Application Security Testing)</strong> 的核心原理</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SAST 是一种<strong>白盒测试</strong>方法。它通过在不实际执行应用程序代码的情况下，对源代码、字节码或二进制代码进行分析，以识别安全漏洞</p><p><strong>“静态”</strong>：指在代码静止不动（未运行时）进行分析</p><p><strong>“白盒”</strong>：指工具拥有并能够查看应用程序的全部内部结构和逻辑（即源代码）</p><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><ol><li><strong>Checkmarx SAST</strong></li></ol><p>Checkmarx SAST拥有SAST工具中最友好的Web用户界面，同时还整合了很多高级功能。即使是那些对软件开发中的安全问题不熟悉的人，也能在这个界面的帮助下快速成长。Checkmarx不仅会识别漏洞，还会对漏洞的危险性做出解释。只需按下一个“最佳修复位置”按钮，开发人员就可以深入了解消除这些问题的最简单、最有效的方法。</p><p>Checkmarx开箱即用，支持超过25种编程语言，可配置为作为CI/CD管道的一部分自动运行，或者设置自定义查询并根据需要运行。它还可以适应任何主流IDE或源代码管理平台</p><ol start="2"><li><strong>CyberRes Fortify (原 Micro Focus Fortify)</strong></li></ol><p>CyberRes Fortify平台同时提供SAST和DAST功能。作为SAST产品，它的可视化界面非常干净简洁，可以很直观地向开发人员展示代码中的特定漏洞以及定期发现的漏洞种类的统计信息（分为810个漏洞类别）。然后，它将开发人员引导至其游戏化的培训界面，该界面使学习安全知识和编写安全代码变得轻松有趣。</p><p>该平台支持27种编程语言和框架，可以在本地部署或用作服务，还可以集成到大多数主流IDE中，例如Eclipse和Visual Studio</p><ol start="3"><li><strong>Perforce Klocwork SAST</strong></li></ol><p>Perforce Klocwork SAST号称即使在最庞大的开发环境中也能提高速度。它适用于用C、C++、Java、JavaScript和Python程序，以及Docker容器。它可以集成到任何主流IDE中，如Visual Studio Code、IntelliJ等。</p><p>该工具的开发人员声称，他们设计Klocwork是为了弥补SAST工具的差距，使其能够在复杂的环境中运行。用户可以使用Klocwork扫描多达数百万行代码组成的大规模代码库。Klocwork使用了一些技巧来进一步减少扫描时间，比如每次只扫描更改的代码区域而不是整个程序。</p><p>Klocwork甚至还能帮助对开发人员进行安全培训。它可完全集成到负责安全和意识培训的Secure Code Warrior培训平台中。因此，Klocwork不但可以发现和修复代码中的问题，还能培训开发人员。</p><ol start="4"><li><strong>Spectral SpectralOps Platform</strong></li></ol><p>Check Point最近收购了Spectral，但仍在积极支持SpectralOps平台，这可能是因为其独特的SAST功能。SpectralOps可以找到开发人员在开发过程中经常硬编码到程序中的API密钥、凭据和令牌等敏感信息。通过查找这些敏感信息和错误安全配置，可以防止程序在开发过程中被恶意用户未授权访问，对于已经部署的应用程序也是如此。</p><p>SpectralOps在软件开发生命周期的每一个步骤都会不断扫描，使用人工智能技术跟踪超过2,000个检测引擎。SpectralOps采用其他测试方法来确保发现可疑情况时不会产生误报。之后，它可以通过各种通信平台向Slack报告其发现、发布JIRA工单或提醒开发人员</p><ol start="5"><li><strong>Veracode Static Analysis SAST</strong></li></ol><p>Veracode静态分析SAST平台是一种云服务，这避免了在本地环境中维护SAST应用程序的复杂性。Veracode采用即时学习原则，可以将易受攻击的代码标记为开发人员正在编写代码。修复代码后，工具可以生成报告，企业可以根据这些报告来表彰那些安全意识较好的开发人员，并通过积极的强化来激励他们。</p><p>除了集成到主流IDE之外，Veracode还注重速度。可以自动扫描程序或应用程序的每个组件，平均扫描时间仅为90秒。而且Veracode平台还能细致地跟踪测试工作，并在在线门户中整理报告。即使在高度复杂或繁忙的开发环境中，这也使得通过审计更容易</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>SAST是基于静态代码分析技术</p><h3 id="静态代码分析技术"><a href="#静态代码分析技术" class="headerlink" title="静态代码分析技术"></a>静态代码分析技术</h3><p>静态代码分析是指在不实际执行程序的情况下，对代码语义和行为进行分析，由此找出程序中由于错误的编码导致异常的程序语义或未定义的行为。通俗的说，静态代码分析就是在代码编写的同时就能找出代码的编码错误。你不需要等待所有代码编写完毕，也不需要构建运行环境，编写测试用例。</p><h4 id="误报原因"><a href="#误报原因" class="headerlink" title="误报原因"></a>误报原因</h4><p>误报指的是 SAST 工具报告了一个安全漏洞，但实际上这段代码在真实运行时是<strong>安全无害</strong>的。</p><p>静态代码分析之所以会出现误报，主要原因在于它无法像程序运行时那样拥有完整的上下文信息，只能依赖于对代码结构的推断</p><ol><li>没有完整的上下文</li><li>对代码语意的理解不完整</li><li>函数调用的模型不准确</li><li>路径可达性问题</li></ol><p>解决方案：</p><p>1.用户自定义配置： 允许用户配置自定义的净化函数、信任的 Source 或 Sink，以及忽略特定的代码路径</p><p>2.基线设置：允许开发者将第一次扫描的结果（通常包含很多误报）审核后设为安全基线，后续只报告新增的或状态发生变化的漏洞</p><p>3.结合运行时信息： 某些高级工具（如 IAST）尝试在测试阶段收集运行时信息，然后反馈给静态分析器，以更好地排除虚假路径</p><p>4.程序切片：仅分析与污点数据流相关的代码部分，以减少需要处理的复杂性</p><h4 id="漏报原因"><a href="#漏报原因" class="headerlink" title="漏报原因"></a>漏报原因</h4><p>漏报指的是 SAST 工具未能发现代码中存在的、<strong>实际可被利用</strong>的安全漏洞</p><p>1.对复杂数据流的追踪失败</p><p>2.无法处理动态和运行时特性</p><p>3.不完整的规则集和模型</p><p>4.跨模块跨语言分析限制</p><p>解决方案：</p><p>1.结合黑盒测试（DAST）</p><p>2.结合IAST</p><p>3.人工代码审计</p><h2 id="词法语法语义"><a href="#词法语法语义" class="headerlink" title="词法语法语义"></a>词法语法语义</h2><h3 id="词法"><a href="#词法" class="headerlink" title="词法"></a>词法</h3><p>词法分析，将原始的字符流转化为有意义的，离散的单元–&gt;词元（type + Lexeme）</p><p>Eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>读取则是按照if，（，x….，if匹配关键词模式，x是字母，匹配标识模式</p><p>空格，注释，换行符等无意义的内容将会被剔除</p><p>产生的词元（token），eg:<code>x</code> ，则为<code>IDENTIFIER x</code></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>语法分析是理解代码的<strong>结构</strong>。它接收词法分析产生的 Tokens 序列，并检查它们是否符合语言的句法规则</p><p>Eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tokens 序列 (<span class="keyword">if</span>, (, x, &gt;=, <span class="number">0</span>, ), &#123;, ...)</span><br></pre></td></tr></table></figure><p>验证序列是否满足语法结构内容:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语言规则规定：IF 语句 = IF 关键词 + ( + 表达式 + ) + 块</span><br></pre></td></tr></table></figure><p>产出：AST</p><p>Eg1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[IfStatement (IF 语句)] --&gt; B[Condition (条件表达式)]</span><br><span class="line">    A --&gt; C[Body (代码块)]</span><br><span class="line"></span><br><span class="line">    B --&gt; D[BinaryExpression (二元运算)]</span><br><span class="line">    D --&gt; E[Identifier (标识符: x)]</span><br><span class="line">    D --&gt; F[Operator (操作符: &gt;=)]</span><br><span class="line">    D --&gt; G[Literal (字面量: <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    C --&gt; H[BlockStatement (块语句)]</span><br><span class="line">    H --&gt; I[... Statement <span class="title function_">List</span> <span class="params">(其他语句)</span>]</span><br><span class="line"></span><br><span class="line">    style A fill:#D1E7F5,stroke:#3C763D</span><br><span class="line">    style B fill:#F5E7D1,stroke:#8A6D3B</span><br><span class="line">    style D fill:#F5E7D1,stroke:#8A6D3B</span><br><span class="line">    style C fill:#DFF0D8,stroke:#3C763D</span><br></pre></td></tr></table></figure><p>Eg2:</p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511252234690.png" alt="img"></p><p>其AST：</p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511252235995.png" alt="img"></p><h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><p>语义分析是理解代码的<strong>含义</strong>。它在 AST 的基础上进行，确保代码在逻辑上和类型上是正确和有意义的，并为执行或安全分析做准备</p><p>1.类型检测</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> = <span class="string">&quot;123&quot;</span></span><br></pre></td></tr></table></figure><p>这在上述的词法和语法可能会通过，因为它们并不关注代码逻辑，但是在语义上会出错</p><p>2.数据流分析</p><p> <strong>追踪</strong>变量的值和状态在程序中的传播路径，多用于污点分析</p><p>3.控制流分析</p><p>确定程序执行的<strong>所有可能路径</strong></p><p>产出：<strong>Control Flow Graph</strong> 和 <strong>Data Flow</strong></p><h2 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h2><p>Intermediate Representation（中间表示）</p><p>IR一般由AST经过类型检查和规范化后转换而来</p><p>它是源程序在编译器或者静态分析器的内部表示，所有的代码分析，优化和转换工作都是基于中间表示进行的</p><p>在现代编译器和静态分析工具中，通常会使用控制流图（Control Flow Graph，CFG）来表示程序的控制流，使用静态单赋值（Static Single Assignment，SSA）来表示程序中数据的使用-定义链（Use-Def Chain），这两个关键数据结构都是AST中没有的</p><p>Eg：</p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511252239772.png" alt="img"></p><p>其IR:</p><p><img src="https://n11-blogs.oss-cn-chengdu.aliyuncs.com/img/202511252240601.png" alt="11"></p><h2 id="IR与AST"><a href="#IR与AST" class="headerlink" title="IR与AST"></a>IR与AST</h2><h3 id="IR在静态代码分析中比AST的准确性高"><a href="#IR在静态代码分析中比AST的准确性高" class="headerlink" title="IR在静态代码分析中比AST的准确性高"></a>IR在静态代码分析中比AST的准确性高</h3><p>原因：<br>对AST进行类型检查和规范化，即可转换为IR。AST上适合做一些代码规范的检查，例如标识符命名规范检查或常见的编码惯用法检查，AST上的检查一般使用图模式匹配的方法</p><p>而IR上能进行更深层次的流敏感分析，过程间分析，上下文敏感分析和对象敏感分析等等，从而实现各种更高难度的程序漏洞检查。相比IR，AST有这些明显的劣势：AST不能很好的表示控制流和数据流，AST做为输入源代码的树状表示，它本身就缺乏表示控制流和控制流的方式。AST是非规范化的，相同语义的结构如果写法不同，它们在AST上的表示也会不同。例如C语言中使用for、while和if/goto表达的循环结构，它们的AST是不一样的；而转换为IR后产生的控制流图是一样的。规范化使得对程序语义的分析更容易，使得检测精确度更高。</p><h3 id="IR在静态分析上的优势"><a href="#IR在静态分析上的优势" class="headerlink" title="IR在静态分析上的优势"></a>IR在静态分析上的优势</h3><p>着重在于稳定性与通用：</p><p>通常AST都是输入语言相关的，比如C程序有对应的C AST，Java程序有对应的Java AST；而IR一般来说是输入语言无关的，不管是C源代码、Java源代码或者其他语言的源代码，它们都能被转换到一个语言无关的IR上。</p><p>我们将各种分析和检测引擎放置在IR上，那么相同的分析引擎和检测引擎，搭配不同语言的检测规则，就可以实现对不同语言编码缺陷的检测。使用IR的另一个好处是相对AST，IR会更稳定。</p><p>例如现在C++规范每3年就会出一个新标准，引入新的语法结构，意味着AST每3年就会出现新的节点需要处理。如果将分析引擎建立在AST基础上，那么分析引擎也需要每3年更新一次处理这些新节点；而如果将分析引擎建立在IR基础上，则仅需将新的AST节点转换为已有的IR结构或操作，从而保持分析引擎基本不受影响</p>]]></content>
      
      
      <categories>
          
          <category> SDL </category>
          
          <category> SAST </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
